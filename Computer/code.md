# 原码、补码、反码

首先我们需要了解 “机器数” 和 “真值” 的概念。众所周知，计算机是使用二进制来表示存储数据的。所以 “机器数” 就是这个数的二进制表示。当然，“机器数” 是可以表示负数的，在计算机中约定最高位为0则表示正数，最高位为1则表示负数，例如一个8位二进制数：00000001 表示1，10000001 表示-1

因为上面机器数的最高位是符号位，所以机器数的形式不能代表它的实际大小，还需要考虑最高位。因此，“真值” 的概念就出现了: 带符号位的机器数的真正数值，就是真值。例: 0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1

原码、补码、反码是机器存储数字的不同编码方式。

**原码**: 符号位加上真值的绝对值。其实也就是机器数。这也是最直观人脑最能理解的编码方式。

```text
[+1]原 = 00000001
[-1]原 = 10000001
```

所以原码的取值范围就是 [11111111, 011111111]，也就是 [-127, 127]

**反码**: 正数的反码是本身，负数的反码符号为不变，其余位取反

```text
[+1] = [00000001]原 = [00000001]反
[-1] = [10000001]原 = [11111110]反
```

**补码**: 正数的补码是本身，负数的补码符号为不变，其余位取反并加1。同时在补码中规定 100000000 为 -128

```text
[+1] = [00000001]原 = [00000001]补
[-1] = [10000001]原 = [11111111]补
```

**为何需要使用 原码、反码、补码**:

由上面的概念，我们知道了对于正数而言，它的三种编码都是一样的，但对于负数，反码和补码的方式并不直观，所以又为什么要保留这两种编码方式呢？

原因就在于提高基础计算的性能以及降低电路逻辑复杂度。首先，对于我们人脑来说，可以根据运算符来判断什么时候用加法，什么时候用减法, 当然对于计算机也可以这样判断，但势必就造成了电路逻辑复杂，试想一下，如果每次计算机在做运算前都要首先判断一下是用加法还是减法，那这个速度就慢了很多了。而且这个加减法是计算机底层操作，一旦它慢了，整个上层应用都会受到影响。

于是乎人们就开始探索将符号位也参与运算，这样就会只保留加法运算，不需要减法了。

首先来看下原码的表现：

```text
计算十进制的表达式: 1-1=0

1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2
```

如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.

为了解决原码的减法问题，出现了反码：

```text
计算十进制的表达式: 1-1=0

1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [00000001]反 + [11111110]反 = [11111111]反 = [10000000]原= -0
```

从上面结果看，使用反码是正确的，但是却出现了-0这个表示，虽然 +0 和 -0 理解上是一样的，但却有瑕疵，而且为后续处理也带来了一定的麻烦，会有 [00000000]原 和 [10000000]原两个编码表示0

于是乎，补码出现了，解决了0的问题以及两个编码的问题：

```text
1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [00000001]补 + [11111111]补 = [00000000]补 = [00000000]原码 = 0
```

这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:

```text
(-1) + (-127) = [10000001]原 + [11111111]原 = [11111111]补 + [10000001]补 = [10000000]补 = -128
```

-1 - 127 的结果应该是 -128，在用补码的运算中，[1000 0000]补 就是 -128。但这里需要注意，实际上就是使用以前的 -0 的补码来表示 -128，所以 -128 并没有对应的原码和反码的表示。

使用了补码不仅修复了0的符号，还解决了存在两个0的问题，而且还能表示一个最低数，这就是为什么8位二进制数，使用原码或反码能表示的范围是 [-127, 127], 而使用补码能表示的范围是 [-128, 127]

因为机器使用补码形式，所以对于编程中常用到的 32 位 int 类型，可以表示的范围是: [-2^31, 2^31 - 1], 因为第一位表示的是符号位，同时补码又可以多保存一个最小值。

## 参考资料

[原码、补码、反码 详解](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html)
